#!/usr/bin/env bash

set -f
die() { set +f ; exit $1 ; }

usage()
{
    cat << 'EOF'
Usage: sfile [options] path pattern
Search though files in a path to find a pattern
Options:
  -x, --ext                  Filter files by the extention. This can be called more then once in a command
  -n, --hide-linenumber      Hide line numbers from output results
  -i, --ignore-case          Search for pattern ignoring the case
  -r, --regex                Use extended regex

  -h, --help, --usage,       This help screen
EOF
    die $1
}

function parse_arguments()
{
    parse_args=()
    local optspec=":hvzx:nir-"
    while [ $# -gt 0 ] ; do
        unset OPTIND && unset OPTARG
        while getopts $optspec OPTION ; do
            case "$OPTION" in
                h) usage 0                   ;;
                x) process_name_arg $OPTARG  ;;
                n) hide_linenumber=1         ;;
                i) grep_arguments+=('-i')    ;;
                r) grep_arguments+=('-E')    ;;
                -)
                    [ $OPTIND -ge 1 ] && optind=$(expr $OPTIND - 1) || optind=$OPTIND
                    eval OPTION="\$$optind"
                    OPTARG=$(echo $OPTION | cut -d'=' -f2)
                    OPTION=$(echo $OPTION | cut -d'=' -f1)
                    case $OPTION in
                        --help|--usage   ) usage 0                                          ;;
                        --ext            ) process_name_arg $OPTARG                         ;;
                        --hide-linenumber) hide_linenumber=1                                ;;
                        --ignore-case    ) grep_arguments+=('-i')                           ;;
                        --regex          ) grep_arguments+=('-E')                           ;;
                        *                ) echo "Invalid option: $OPTION $OPTARG" ; usage 1 ;;
                    esac
                    OPTIND=1 ; shift ;;
                \?) echo "Invalid option: $OPTION $OPTARG" ; usage 1 ;;
            esac
        done
        shift $((OPTIND-1)) ; parse_args+=("$1") ; shift
    done
}

# function takes in the argument that was passed by the command line and processes
# it. names are saved to array 'name_arguments'
function process_name_arg()
{
    [[ -z $has_processed_name_before ]] && {
        name_arguments+=('(' '-name' "*.$1")
        has_processed_name_before=1
    } || {
        name_arguments+=('-o' '-name' "*.$1")
    }
}

function main()
{
    # If no arguments are passed then print usage and exit
    [[ $# -eq 0 ]] && usage && die 0

    parse_arguments "$@"

    # if not hiding line number add the option
    [[ -z $hide_linenumber ]] && grep_arguments+=('-n')

    # if there are name arguments then close the ()
    [[ -n $has_processed_name_before ]] && name_arguments+=(')')

    # if no path or pattern then exit
    [[ ${#parse_args[@]} -eq 0 ]] && echo "Error: no search path passed!" && die 1
    [[ ${#parse_args[@]} -eq 1 ]] && echo "Error: no pattern was passed!" && die 1

    # setting the search paths to everything but the last argument. The last argument in the array
    # is the search pattern to use. Settings search path to be the parse_args array and the popping
    # off the last argument in the array. The pattern is the last argument of the parse_args array
    search_path=("${parse_args[@]}")
    unset 'search_path[${#search_path[@]}-1]'
    pattern="${parse_args[-1]}"

    find "${search_path[@]}" -type f "${name_arguments[@]}" "${find_arguments[@]}" -exec grep --color=always -I "${grep_arguments[@]}" "$pattern" {} +
    die 0
}

main "$@"


# parse arguments snippet 

# function parse_arguments()
# {
#     parse_args=()
#     local optspec=""
#     while [ $# -gt 0 ] ; do
#         unset OPTIND ; unset OPTARG
#         while getopts $optspec OPTION ; do
#             case "$OPTION" in
#                 h) usage 0 ;;
#                 -)
#                     [ $OPTIND -ge 1 ] && optind=$(expr $OPTIND - 1) || optind=$OPTIND
#                     eval OPTION="\$$optind"
#                     OPTARG=$(echo $OPTION | cut -d'=' -f2)
#                     OPTION=$(echo $OPTION | cut -d'=' -f1)
#                     case $OPTION in
#                         --help|--usage) usage 0 ;;
#                         *) echo "Invalid option: $OPTION $OPTARG" ;;
#                     esac
#                     OPTIND=1 ; shift ;;
#                 \?) echo "Invalid option: $OPTION $OPTARG" ; usage 1 ;;
#             esac
#         done
#         shift $((OPTIND-1)) ; parse_args+=($1) ; shift
#     done
# }
