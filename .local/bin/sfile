#!/usr/bin/env bash

set -f
die() { set +f ; exit $1 ; }

usage()
{
    echo "Usage: sfile [options] path pattern
Search though files in a path to find a pattern
Options:
  -z, --dryrun               Show the underlying command but do not run it
  -x, --ext                  Filter files by the extention. This can be called more then once in a command
  -n, --hide-linenumber      Hide line numbers from output results
  -i, --ignore-case          Search for pattern ignoring the case
  -r, --regex                Use extended regex

  -h, --help, --usage,       This help screen
  -v, --verbose              Show verbose output of commands
"
    die $1
}

function parse_arguments()
{
    parse_args=()
    local optspec=":hvzx:nir-"
    while [ $# -gt 0 ] ; do
        unset OPTIND && unset OPTARG
        while getopts $optspec OPTION ; do
            case "$OPTION" in
                h) usage 0                        ;;
                v) verbose_output=1               ;;
                z) do_dryrun=1 ; verbose_output=1 ;;
                x) process_name_arg $OPTARG       ;;
                n) hide_linenumber=1              ;;
                i) grep_arguments+=('-i')         ;;
                r) grep_arguments+=('-E')         ;;
                -)
                    [ $OPTIND -ge 1 ] && optind=$(expr $OPTIND - 1) || optind=$OPTIND
                    eval OPTION="\$$optind"
                    OPTARG=$(echo $OPTION | cut -d'=' -f2)
                    OPTION=$(echo $OPTION | cut -d'=' -f1)
                    case $OPTION in
                        --help|--usage   ) usage 0                                          ;;
                        --verbose        ) verbose_output=1                                 ;;
                        --dryrun         ) do_dryrun=1                                      ;;
                        --ext            ) process_name_arg $OPTARG                         ;;
                        --hide-linenumber) hide_linenumber=1                                ;;
                        --ignore-case    ) grep_arguments+=('-i')                           ;;
                        --regex          ) grep_arguments+=('-E')                           ;;
                        *                ) echo "Invalid option: $OPTION $OPTARG" ; usage 1 ;;
                    esac
                    OPTIND=1 ; shift ;;
                \?) echo "Invalid option: $OPTION $OPTARG" ; usage 1 ;;
            esac
        done
        shift $((OPTIND-1)) ; parse_args+=($1) ; shift
    done
}

# function takes in the argument that was passed by the command line and processes
# it. names are saved to array 'name_arguments'
function process_name_arg()
{
    [[ -z $has_processed_name_before ]] && {
        name_arguments+=('(' '-name' "*.$1")
        has_processed_name_before=1
    } || {
        name_arguments+=('-o' '-name' "*.$1")
    }
}

function main()
{
    # If no arguments are passed then print usage and exit
    [[ $# -eq 0 ]] && usage && die 0

    parse_arguments "$@"

    # if not hiding line number add the option
    [[ -z $hide_linenumber ]] && grep_arguments+=('-n')

    # if there are name arguments then close the ()
    [[ -n $has_processed_name_before ]] && name_arguments+=(')')

    # if no path or pattern then exit
    [[ ${#parse_args[@]} -eq 0 ]] && echo "Error: no search path passed!" && die 1
    [[ ${#parse_args[@]} -eq 1 ]] && echo "Error: no pattern was passed!" && die 1
    search_path="${parse_args[0]}"
    pattern="${parse_args[1]}"

    cmd=$(echo find $search_path -type f ${name_arguments[@]} ${find_arguments[@]} -exec grep --color=always -I ${grep_arguments[@]} $pattern {} +)
    [[ -n $verbose_output ]] && echo $cmd
    [[ -n $dryrun ]] || $cmd
    die 0
}

main "$@"


# parse arguments snippet 

# function parse_arguments()
# {
#     parse_args=()
#     local optspec=""
#     while [ $# -gt 0 ] ; do
#         unset OPTIND ; unset OPTARG
#         while getopts $optspec OPTION ; do
#             case "$OPTION" in
#                 h) usage 0 ;;
#                 -)
#                     [ $OPTIND -ge 1 ] && optind=$(expr $OPTIND - 1) || optind=$OPTIND
#                     eval OPTION="\$$optind"
#                     OPTARG=$(echo $OPTION | cut -d'=' -f2)
#                     OPTION=$(echo $OPTION | cut -d'=' -f1)
#                     case $OPTION in
#                         --help|--usage) usage 0 ;;
#                         *) echo "Invalid option: $OPTION $OPTARG" ;;
#                     esac
#                     OPTIND=1 ; shift ;;
#                 \?) echo "Invalid option: $OPTION $OPTARG" ; usage 1 ;;
#             esac
#         done
#         shift $((OPTIND-1)) ; parse_args+=($1) ; shift
#     done
# }
