#!/usr/bin/env bash

set -f
die() { set +f ; exit $1 ; }

usage()
{
    cat << 'EOF'
Usage: srfile [options] path pattern
Search and replace though files in a path to find a pattern
Options:
  -h, --help, --usage,       This help screen
  -v, --verbose              Show verbose output of commands
  -z, --dryrun               Show the underlying command but do not run it. Make sure that you add the
                             sufix 'p' at the end of the pattern to have output
  -x, --ext                  Filter files by the extention. This can be called more then once in a command
  -i, --inplace              Make substitution in place
EOF
    die 0
}

function parse_arguments()
{
    parse_args=()
    local optspec=":hvzx:i"
    while [ $# -gt 0 ] ; do
        unset OPTIND ; unset OPTARG
        while getopts $optspec OPTION ; do
            case "$OPTION" in
                h) usage 0                  ;;
                v) verbose_output=1         ;;
                z) do_dryrun=1              ;;
                x) process_name_arg $OPTARG ;;
                i) sed_arguments+=('-i')    ;;
                -)
                    [ $OPTIND -ge 1 ] && optind=$(expr $OPTIND - 1) || optind=$OPTIND
                    eval OPTION="\$$optind"
                    OPTARG=$(echo $OPTION | cut -d'=' -f2)
                    OPTION=$(echo $OPTION | cut -d'=' -f1)
                    case $OPTION in
                        --help|--usage) usage 0                                ;;
                        --verbose     ) verbose_output=1                       ;;
                        --dryrun      ) do_dryrun=1                            ;;
                        --ext         ) process_name_arg $OPTARG               ;;
                        --inplace     ) sed_arguments+=('-i')                  ;;
                        *             ) echo "Invalid option: $OPTION $OPTARG" ;;
                    esac
                    OPTIND=1 ; shift ;;
                \?) echo "Invalid option: $OPTION $OPTARG" ;;
            esac
        done
        shift $((OPTIND-1)) ; parse_args+=($1) ; shift
    done
}

function process_name_arg()
{
    [[ -z $has_processed_name_before ]] && {
        name_arguments+=('(' '-name' "*.$1")
        has_processed_name_before=1
    } || {
        name_arguments+=('-o' '-name' "*.$1")
    }
}

function main()
{
    # If no arguments are passed then print usage and exit
    [[ $# -eq 0 ]] && usage && die 0

    parse_arguments "$@"

    # if no path or pattern then exit
    [[ ${#parse_args[@]} -eq 0 ]] && echo "Error: no search path passed!" && die 1
    [[ ${#parse_args[@]} -eq 1 ]] && echo "Error: no pattern was passed!" && die 1
    search_path="${parse_args[0]}"
    replacement_pattern="${parse_args[1]}"

    # if there are name arguments then close the ()
    [[ -n $has_processed_name_before ]] && name_arguments+=(')')

    [[ -n $do_dryrun ]] && pattern_suffix="p"

    cmd=$(echo find $search_path -type f ${name_arguments[@]} ${find_arguments[@]} -exec sed ${sed_arguments[@]} -e $replacement_pattern$pattern_suffix -- {} +)
    [[ -n $verbose_output ]] && echo $cmd
    $cmd

    die 0
}

main "$@"
